# Triangle, pentagonal, and hexagonal numbers are generated by the following
# formulae:
#
# Triangle        Tn=n(n+1)/2     1, 3, 6, 10, 15, ...
# Pentagonal      Pn=n(3n−1)/2    1, 5, 12, 22, 35, ...
# Hexagonal       Hn=n(2n−1)      1, 6, 15, 28, 45, ...
#
# It can be verified that T285 = P165 = H143 = 40755.
#
# Find the next triangle number that is also pentagonal and hexagonal.

using ProjectEulerSolutions

# Calculate different pentagonal and hexagonal numbers, since every hexagonal
# number is also a triangular number.  Then find the intersection
function p045solution_set(n::Integer=166)::Integer

    pentvals = collect(165:n)
    hexvals = collect(143:n)
    pentset = Set(fld.(pentvals .* (3 .* pentvals .- 1), 2))
    hexset = Set(hexvals .* (2 .* hexvals .- 1))

    return maximum(intersect(pentset, hexset))
end

# Ignoring triangular numbers, solving for when the pentagonal and hexagonal
# equations are equal gives a "Diophantine equation" of the form 
# axx + bxy + cyy + dx + ey + f = 0.  Plugging in, we can get a recursive
# solution from https://www.alpertron.com.ar/QUAD.HTM and iterate through a
# single step.  This idea came from https://projecteuler.net/thread=45
function p045solution_diophantine(n::Integer=0)::Integer
    # x0 = 1
    # y0 = 1
    x1 = 165
    y1 = 143
    x2 = 97 * x1 + 112 * y1 - 44
    y2 = 84 * x1 + 97 * y1 - 38

    return y2 * (2 * y2 - 1) # convert back to hexagonal number from index
end

p045 = Problems.Problem(Dict("Set" => p045solution_set,
                             "Diophantine" => p045solution_diophantine))

Problems.benchmark(p045, 50_000)